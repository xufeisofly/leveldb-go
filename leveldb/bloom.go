package leveldb

import "github.com/xufeisofly/leveldb-go/util"

type bloomFilterPolicy struct {
	bitsPerKey int
	k          int
}

var _ FilterPolicy = (*bloomFilterPolicy)(nil)

// Return a new filter policy that uses a bloom filter with approximately
// the specified number of bits per key.  A good value for bits_per_key
// is 10, which yields a filter with ~ 1% false positive rate.
//
// Callers must delete the result after any database that is using the
// result has been closed.
//
// Note: if you are using a custom comparator that ignores some parts
// of the keys being compared, you must not use NewBloomFilterPolicy()
// and must provide your own FilterPolicy that also ignores the
// corresponding parts of the keys.  For example, if the comparator
// ignores trailing spaces, it would be incorrect to use a
// FilterPolicy (like NewBloomFilterPolicy) that does not ignore
// trailing spaces in keys.
func NewBloomFilterPolicy(bitsPerKey int) FilterPolicy {
	k := int(float64(bitsPerKey) * 0.69) // 0.69 =~ ln(2)
	if k < 1 {
		k = 1
	}
	if k > 30 {
		k = 30
	}
	return &bloomFilterPolicy{
		bitsPerKey: bitsPerKey,
		k:          k,
	}
}

func (f *bloomFilterPolicy) Name() string {
	return "leveldb.BuiltinBloomFilter2"
}

func (f *bloomFilterPolicy) CreateFilter(keys [][]byte, dst *[]byte) {
	// Compute bloom filter size (in both bits and bytes)
	n := len(keys)
	bits := n * f.bitsPerKey
	// for small n, we can see a very high fase positive rate. fix it by enforcing
	// a minimum bloom filter length
	if bits < 64 {
		bits = 64
	}

	bytes := (bits + 7) / 8
	bits = bytes * 8

	array := make([]byte, bytes)
	for i := 0; i < n; i++ {
		// Use double-hashing to generate a sequence of hash values.
		// See analysis in [Kirsch,Mitzenmacher 2006].
		h := BloomHash(keys[i])
		delta := (h >> 17) | (h << 15)
		for j := 0; j < f.k; j++ {
			bitpos := h % uint32(bits)
			array[bitpos/8] |= (1 << (bitpos % 8))
			h += delta
		}
	}
	// encode k into end of filter array
	array = append(array, byte(f.k))
	*dst = append(*dst, array...)
}

func (f *bloomFilterPolicy) KeyMayMatch(key, bloomFilter []byte) bool {
	l := len(bloomFilter)
	if l < 2 {
		return false
	}

	bits := (l - 1) * 8

	// Use the encoded k so that we can read filters generated by
	// bloom filters created using different parameters.
	k := int(bloomFilter[l-1])
	if k > 30 {
		return true
	}

	h := BloomHash(key)
	delta := (h >> 17) | (h << 15)
	for j := 0; j < k; j++ {
		bitpos := h % uint32(bits)
		if (bloomFilter[bitpos/8] & (1 << (bitpos % 8))) == 0 {
			return false
		}
		h += delta
	}

	return true
}

func BloomHash(key []byte) uint32 {
	return util.Hash(key, 0xbc9f1d34)
}
